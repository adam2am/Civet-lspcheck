import TSService from "../../source/lib/typescript-service.mts"
import { pathToFileURL } from "url"
import { TextDocument } from "vscode-languageserver-textdocument"
import { handleSemanticTokensFull, getSemanticLegend } from "../../source/features/semanticToken.mts"

assert from assert

// Minimal content focusing on class method and instance property
civetContent := """
class ThisTypeExample{
  value: number := 0
  
  setValue(value: number)
    @value = value
}

enum Color
  Red
  Green
  Blue
"""

tsContent := """
class ThisTypeExample {
  readonly value: number = 0;
  
  setValue(value: number) {
    this.value = value;
  }
}

enum Color {
  Red,
  Green,
  Blue,
}
"""

civetCoffeeCommentContent := """
"civet coffeeComment"
value = 1
# hello from coffee comment
"""

civetCoffeeCommentEdgeCases := """
"civet coffeeComment"
# standalone comment at BOL
code = 1  # trailing comment after code
array := [1, 2, 3]
len := array.#
class MyClass
  #privateField = 42
  publicField = 100
index := 2
floor := 10
half := floor # / 2
userName := "world"
greeting := "Hello #\{userName\}!"
multiline := \"""
value here
# this is inside triple quotes
more text
\"""
"""

createTestDocument := (content: string, uri: string) ->
  TextDocument.create(uri, "civet", 0, content)

loadTestFile := async (service: Awaited<ReturnType<typeof TSService>>, content: string, fileName: string) ->
  document := createTestDocument(content, pathToFileURL(fileName).href)
  service.host.addOrUpdateDocument(document)
  return document

posOf := (document: TextDocument, needle: string) ->
  text := document.getText()
  idx := text.indexOf(needle)
  assert idx >= 0, `Marker not found: ${needle}`
  document.positionAt(idx)

// Decode LSP semantic tokens (relative-encoded) into absolute positions
// Returns array of { line, char, length, typeIdx, typeName, modifiersMask, modifierNames }
decodeTokens := (data: number[], legend = getSemanticLegend()) ->
  tokens := []
  let line = 0
  let char = 0
  let i = 0
  while i < data.length
    deltaLine := data[i]
    deltaStart := data[i + 1]
    length := data[i + 2]
    typeIdx := data[i + 3]
    modMask := data[i + 4]

    line += deltaLine
    if deltaLine == 0
      char += deltaStart
    else
      char = deltaStart

    tokens.push({
      line,
      char,
      length,
      typeIdx,
      typeName: legend.tokenTypes[typeIdx],
      modifiersMask: modMask,
      modifierNames: legend.tokenModifiers.filter((_, bit) => (modMask & (1 << bit)) != 0),
    })
    i += 5
  tokens

getTokenCovering := (tokens, line: number, ch: number) ->
  for t in tokens
    if t.line == line and ch >= t.char and ch < t.char + t.length
      return t
  undefined

materializeTokens := (document: TextDocument, tokens) ->
  tokens.map (t) ->
    startOffset := document.offsetAt({ line: t.line, character: t.char })
    endOffset := document.offsetAt({ line: t.line, character: t.char + t.length })
    text := document.getText().slice(startOffset, endOffset)
    Object.assign({}, t, { text })

makeDeps := (service, document) ->
  {
    ensureServiceForSourcePath: async (_path: string) => service
    documentToSourcePath: (doc) => doc.uri.replace("file://", "")
    documents: { get: (uri: string) => if uri == document.uri then document else undefined }
    updating: async () => true
    debug: { semanticTokens: true }
  }

describe "Semantic Tokens - Edge Cases", ->
  @timeout 10000

  let service: Awaited<ReturnType<typeof TSService>>

  before async ->
    service = await TSService(pathToFileURL("./").href)
    await service.loadPlugins()

  it "class method name 'setValue' is typed as method (declaration) in Civet", async ->
    civetDoc := await loadTestFile(service, civetContent, "./edgecases.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    methodTok := tokens.find((t) => t.text == "setValue")

    console.log "[CIVET METHOD] Found token:", methodTok
    console.log "[CIVET ALL TOKENS]", tokens.map((t) => `${t.text}:${t.typeName}`)

    assert methodTok, "Expected a token at method name"
    assert methodTok.typeName == "method", `Expected method, got ${methodTok.typeName}`
    assert methodTok.modifierNames.includes("declaration"), `Expected declaration modifier, got ${methodTok.modifierNames}`

  it "instance property '@value' is typed as property (readonly) in Civet", async ->
    civetDoc := await loadTestFile(service, civetContent, "./edgecases.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    // token may be either "@value" or "value" depending on mapping; accept both
    propTok := tokens.find((t) => t.text == "@value" or t.text == "value")

    console.log "[CIVET PROPERTY] Found token:", propTok
    console.log "[CIVET ALL TOKENS]", tokens.map((t) => `${t.text}:${t.typeName}`)

    assert propTok, "Expected a token at @value"
    assert propTok.typeName == "property", `Expected property, got ${propTok.typeName}`
    assert propTok.modifierNames.includes("readonly"), `Expected readonly modifier, got ${propTok.modifierNames}`

  it "TypeScript parity: method and property classifications match in TS", async ->
    tsDoc := await loadTestFile(service, tsContent, "./edgecases.ts")
    deps := makeDeps(service, tsDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: tsDoc.uri } }, deps)
    tokens := materializeTokens(tsDoc, decodeTokens(result.data))

    methodTok := tokens.find((t) => t.text == "setValue")
    propTok := tokens.find((t) => t.text == "value")

    console.log "[TS METHOD] Found token:", methodTok
    console.log "[TS PROPERTY] Found token:", propTok
    console.log "[TS ALL TOKENS]", tokens.map((t) => `${t.text}:${t.typeName}`)

    assert methodTok && methodTok.typeName == "method" && methodTok.modifierNames.includes("declaration"), "TS method expected method+declaration"
    assert propTok && propTok.typeName == "property" && propTok.modifierNames.includes("readonly"), "TS property expected property+readonly"

  it "enum member 'Red' is typed as enumMember (declaration, readonly) in Civet", async ->
    civetDoc := await loadTestFile(service, civetContent, "./edgecases.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    redTok := tokens.find((t) => t.text == "Red")
    assert redTok, "Expected a token for enum member 'Red'"
    assert redTok.typeName == "enumMember", `Expected enumMember, got ${redTok.typeName}`
    assert redTok.modifierNames.includes("declaration"), `Expected declaration modifier, got ${redTok.modifierNames}`
    assert redTok.modifierNames.includes("readonly"), `Expected readonly modifier, got ${redTok.modifierNames}`

  it "TypeScript parity: enum member 'Red' is typed as enumMember in TS", async ->
    tsDoc := await loadTestFile(service, tsContent, "./edgecases.ts")
    deps := makeDeps(service, tsDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: tsDoc.uri } }, deps)
    tokens := materializeTokens(tsDoc, decodeTokens(result.data))

    redTok := tokens.find((t) => t.text == "Red")
    assert redTok && redTok.typeName == "enumMember" && redTok.modifierNames.includes("declaration") && redTok.modifierNames.includes("readonly"), "TS enumMember expected enumMember+declaration+readonly"

  it "classifies Civet coffee-style '#' comments when enabled", async ->
    civetDoc := await loadTestFile(service, civetCoffeeCommentContent, "./coffee-comment.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    commentTok := tokens.find((t) => t.typeName == "comment")

    assert commentTok, "Expected a comment token when coffeeComment is enabled"
    assert commentTok.text.trim().startsWith("#"), "Comment token should originate from '#' line"

  it "coffee comment edge case: standalone comment at BOL is classified as comment", async ->
    civetDoc := await loadTestFile(service, civetCoffeeCommentEdgeCases, "./coffee-edge.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    // Find the standalone comment on line 1 (after directive)
    commentTok := tokens.find((t) => t.text.includes("# standalone comment"))

    console.log "[EDGE-STANDALONE] Found token:", commentTok
    console.log "[EDGE-ALL]", tokens.filter((t) => t.text.includes("#")).map((t) => `${t.text}:${t.typeName}`)

    assert commentTok, "Expected standalone '#' comment to be classified as comment"
    assert commentTok.typeName == "comment", `Expected comment, got ${commentTok.typeName}`

  it "coffee comment edge case: trailing comment after code is classified as comment", async ->
    civetDoc := await loadTestFile(service, civetCoffeeCommentEdgeCases, "./coffee-edge.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    // Find trailing comment after "code = 1"
    commentTok := tokens.find((t) => t.text.includes("# trailing comment"))

    console.log "[EDGE-TRAILING] Found token:", commentTok

    assert commentTok, "Expected trailing '#' comment to be classified as comment"
    assert commentTok.typeName == "comment", `Expected comment, got ${commentTok.typeName}`

  it "coffee comment edge case: length shorthand 'array.#' is NOT classified as comment", async ->
    civetDoc := await loadTestFile(service, civetCoffeeCommentEdgeCases, "./coffee-edge.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    // Find line with "array.#" - the # should NOT be a comment token
    lengthLine := civetDoc.getText().split(/\r?\n/).findIndex((line) => line.includes("array.#"))
    assert lengthLine >= 0, "Should find line with array.# in test content"

    // Check that there's no comment token on that line starting with "#" alone
    hashTokensOnLine := tokens.filter((t) => t.line == lengthLine && t.text == "#")
    commentTokensOnLine := hashTokensOnLine.filter((t) => t.typeName == "comment")

    console.log "[EDGE-LENGTH] Line:", lengthLine, "Hash tokens:", hashTokensOnLine, "Comment tokens:", commentTokensOnLine

    assert commentTokensOnLine.length == 0, `Expected no comment token for 'array.#' length shorthand`

  it "coffee comment edge case: private field '#privateField' is NOT classified as comment", async ->
    civetDoc := await loadTestFile(service, civetCoffeeCommentEdgeCases, "./coffee-edge.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    // Find line with "#privateField"
    privateLine := civetDoc.getText().split(/\r?\n/).findIndex((line) => line.includes("#privateField"))
    assert privateLine >= 0, "Should find line with #privateField in test content"

    // The "#privateField" should not be classified as a comment token that starts at column 2
    // (it might be classified as property/variable but not as comment)
    commentTokensOnLine := tokens.filter((t) => t.line == privateLine && t.typeName == "comment" && t.char == 2)

    console.log "[EDGE-PRIVATE] Line:", privateLine, "Comment tokens:", commentTokensOnLine

    assert commentTokensOnLine.length == 0, `Expected no comment token for private field '#privateField'`

  it "coffee comment edge case: division operator '# / 2' is NOT classified as comment", async ->
    civetDoc := await loadTestFile(service, civetCoffeeCommentEdgeCases, "./coffee-edge.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    // Find line with "floor # / 2"
    divLine := civetDoc.getText().split(/\r?\n/).findIndex((line) => line.includes("floor # / 2"))
    assert divLine >= 0, "Should find line with 'floor # / 2' in test content"

    // The "#" before "/" should NOT be classified as a comment
    commentTokensOnLine := tokens.filter((t) => t.line == divLine && t.typeName == "comment" && t.text.trim().startsWith("#"))

    console.log "[EDGE-DIV] Line:", divLine, "Comment tokens:", commentTokensOnLine

    assert commentTokensOnLine.length == 0, `Expected no comment token for division operator '# / 2'`

  it "coffee comment edge case: string interpolation '#{userName}' is NOT classified as comment", async ->
    civetDoc := await loadTestFile(service, civetCoffeeCommentEdgeCases, "./coffee-edge.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    // Find line with "#{userName}"
    interpLine := civetDoc.getText().split(/\r?\n/).findIndex((line) => line.includes("#{userName}"))
    assert interpLine >= 0, "Should find line with '#{userName}' in test content"

    // The "#{" inside the string should NOT be classified as a comment
    commentTokensOnLine := tokens.filter((t) => t.line == interpLine && t.typeName == "comment" && t.text.includes("#"))

    console.log "[EDGE-INTERP] Line:", interpLine, "Comment tokens:", commentTokensOnLine

    assert commentTokensOnLine.length == 0, `Expected no comment token for string interpolation '#{userName}'`

  it "coffee comment edge case: '#' inside triple-quoted strings is NOT classified as comment", async ->
    civetDoc := await loadTestFile(service, civetCoffeeCommentEdgeCases, "./coffee-edge.civet")
    deps := makeDeps(service, civetDoc)
    result := await handleSemanticTokensFull({ textDocument: { uri: civetDoc.uri } }, deps)
    tokens := materializeTokens(civetDoc, decodeTokens(result.data))

    // Find line with "# this is inside triple quotes"
    tripleLine := civetDoc.getText().split(/\r?\n/).findIndex((line) => line.includes("# this is inside triple quotes"))
    assert tripleLine >= 0, "Should find line with '# this is inside triple quotes' in test content"

    // The "#" inside the triple-quoted string should NOT be classified as a comment
    commentTokensOnLine := tokens.filter((t) => t.line == tripleLine && t.typeName == "comment")

    console.log "[EDGE-TRIPLE] Line:", tripleLine, "Comment tokens:", commentTokensOnLine

    assert commentTokensOnLine.length == 0, `Expected no comment token for '#' inside triple-quoted string`
